{
    "docs": [
        {
            "location": "/", 
            "text": "BioAlignments.jl\n\n\n \n \n \n \n \n \n \n\n\nDevelopment builds:\n \n \n \n\n\n\n\nDescription\n\n\nBioAlignments.jl provides alignment algorithms, data structures, and I/O tools for SAM and BAM file formats.\n\n\n\n\nInstallation\n\n\nInstall BioAlignments from the Julia REPL:\n\n\njulia\n \nPkg\n.\nadd\n(\nBioAlignments\n)\n\n\n\n\n\n\nIf you are interested in the cutting edge of the development, please check out the master branch to try new features before release.\n\n\n\n\nContributing and Questions\n\n\nWe appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features. Please go to the \ncontributing section of the documentation\n for more information.\n\n\nIf you have a question about contributing or using this package, you are encouraged to use the \nBio category of the Julia discourse site\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#bioalignmentsjl", 
            "text": "Development builds:", 
            "title": "BioAlignments.jl"
        }, 
        {
            "location": "/#description", 
            "text": "BioAlignments.jl provides alignment algorithms, data structures, and I/O tools for SAM and BAM file formats.", 
            "title": "Description"
        }, 
        {
            "location": "/#installation", 
            "text": "Install BioAlignments from the Julia REPL:  julia   Pkg . add ( BioAlignments )   If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.", 
            "title": "Installation"
        }, 
        {
            "location": "/#contributing-and-questions", 
            "text": "We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features. Please go to the  contributing section of the documentation  for more information.  If you have a question about contributing or using this package, you are encouraged to use the  Bio category of the Julia discourse site .", 
            "title": "Contributing and Questions"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\nBioAlignments.jl implements pairwise alignment algorithms. This is an example of globally aligning two amino acid sequences under an affine-gap scoding model:\n\n\nusing\n \nBioSequences\n\n\nusing\n \nBioAlignments\n\n\nseq1\n \n=\n \naa\nEPVTSHPKAVSPTETKPTEKGQHLPVSAPPKITQSLKAEASKDIAKLTCAVESSALCA\n\n\nseq2\n \n=\n \naa\nEPSHPKAVSPTETKPTPTEKVQHLPVSAPPKITQFLKAEASKEIAKLTCVVESSVLRA\n\n\nmodel\n \n=\n \nAffineGapScoreModel\n(\nBLOSUM62\n,\n \ngap_open\n=-\n10\n,\n \ngap_extend\n=-\n1\n)\n\n\nalign\n \n=\n \npairalign\n(\nGlobalAlignment\n(),\n \nseq1\n,\n \nseq2\n,\n \nmodel\n)\n\n\nprintln\n(\nalign\n)\n\n\n\n\n\n\nBioAlignments.PairwiseAlignmentResult{Int64,BioSequences.BioSequence{BioSequences.AminoAcidAlphabet},BioSequences.BioSequence{BioSequences.AminoAcidAlphabet}}:\n  score: 223\n  seq:  1 EPVTSHPKAVSPTETKPT--EKGQHLPVSAPPKITQSLKAEASKDIAKLTCAVESSALCA 58\n          ||  ||||||||||||||  || ||||||||||||| ||||||| |||||| |||| | |\n  ref:  1 EP--SHPKAVSPTETKPTPTEKVQHLPVSAPPKITQFLKAEASKEIAKLTCVVESSVLRA 58\n\n\n\n\n\nBioAlignments.jl also supports data formats for high-throughput sequencing technologies. The BAM file, one of the most commonly used file format to store aligned fragments, can be scanned as follows:\n\n\nusing\n \nBioAlignments\n\n\nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n \ndo\n \nreader\n\n    \nfor\n \nrecord\n \nin\n \nreader\n\n        \n@show\n \nBAM\n.\nrefname\n(\nrecord\n)\n\n        \n@show\n \nBAM\n.\nposition\n(\nrecord\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nBAM.refname(record) = \nCHROMOSOME_I\n\nBAM.position(record) = 2", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "BioAlignments.jl implements pairwise alignment algorithms. This is an example of globally aligning two amino acid sequences under an affine-gap scoding model:  using   BioSequences  using   BioAlignments  seq1   =   aa EPVTSHPKAVSPTETKPTEKGQHLPVSAPPKITQSLKAEASKDIAKLTCAVESSALCA  seq2   =   aa EPSHPKAVSPTETKPTPTEKVQHLPVSAPPKITQFLKAEASKEIAKLTCVVESSVLRA  model   =   AffineGapScoreModel ( BLOSUM62 ,   gap_open =- 10 ,   gap_extend =- 1 )  align   =   pairalign ( GlobalAlignment (),   seq1 ,   seq2 ,   model )  println ( align )   BioAlignments.PairwiseAlignmentResult{Int64,BioSequences.BioSequence{BioSequences.AminoAcidAlphabet},BioSequences.BioSequence{BioSequences.AminoAcidAlphabet}}:\n  score: 223\n  seq:  1 EPVTSHPKAVSPTETKPT--EKGQHLPVSAPPKITQSLKAEASKDIAKLTCAVESSALCA 58\n          ||  ||||||||||||||  || ||||||||||||| ||||||| |||||| |||| | |\n  ref:  1 EP--SHPKAVSPTETKPTPTEKVQHLPVSAPPKITQFLKAEASKEIAKLTCVVESSVLRA 58  BioAlignments.jl also supports data formats for high-throughput sequencing technologies. The BAM file, one of the most commonly used file format to store aligned fragments, can be scanned as follows:  using   BioAlignments  open ( BAM . Reader ,   data.bam )   do   reader \n     for   record   in   reader \n         @show   BAM . refname ( record ) \n         @show   BAM . position ( record ) \n     end  end   BAM.refname(record) =  CHROMOSOME_I \nBAM.position(record) = 2", 
            "title": "Usage"
        }, 
        {
            "location": "/alignments/", 
            "text": "Sequence Alignments\n\n\nThe \nBioAlignments\n module contains tools for computing and working with sequence alignments.\n\n\n\n\nRepresenting alignments\n\n\nThe \nAlignment\n type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of \nedit operations\n performed on that reference to transform it to the query sequence.\n\n\nTo represent an alignment we use a series of \"anchors\" stored in the \nAlignmentAnchor\n type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.\n\n\nimmutable\n \nAlignmentAnchor\n\n    \nseqpos\n::\nInt\n\n    \nrefpos\n::\nInt\n\n    \nop\n::\nOperation\n\n\nend\n\n\n\n\n\n\nEvery alignment starts with a special \nOP_START\n operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.\n\n\nFor example, consider the following alignment:\n\n\n              0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27\n\n\n\n\n\nUsing anchors we would represent this as the following series of anchors:\n\n\n[\n\n    \nAlignmentAnchor\n(\n \n0\n,\n  \n4\n,\n \nOP_START\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n  \n8\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n \n4\n,\n \n12\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n \n9\n,\n \n17\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n12\n,\n \n17\n,\n \nOP_INSERT\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n20\n,\n \nOP_MATCH\n),\n\n    \nAlignmentAnchor\n(\n15\n,\n \n23\n,\n \nOP_DELETE\n),\n\n    \nAlignmentAnchor\n(\n19\n,\n \n27\n,\n \nOP_MATCH\n)\n\n\n]\n\n\n\n\n\n\nAn \nAlignment\n object can be created from a series of anchors:\n\n\njulia\n Alignment([\n           AlignmentAnchor(0,  4, OP_START),\n           AlignmentAnchor(4,  8, OP_MATCH),\n           AlignmentAnchor(4, 12, OP_DELETE)\n       ])\nBioAlignments.Alignment:\n  aligned range:\n    seq: 0-4\n    ref: 4-12\n  CIGAR string: 4M4D\n\n\n\n\n\n\n\nOperations\n\n\nAlignment operations follow closely from those used in the \nSAM/BAM format\n and are stored in the \nOperation\n bitstype.\n\n\n\n\n\n\n\n\nOperation\n\n\nOperation Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOP_MATCH\n\n\nmatch\n\n\nnon-specific match\n\n\n\n\n\n\nOP_INSERT\n\n\ninsert\n\n\ninsertion into reference sequence\n\n\n\n\n\n\nOP_DELETE\n\n\ndelete\n\n\ndeletion from reference sequence\n\n\n\n\n\n\nOP_SKIP\n\n\ndelete\n\n\n(typically long) deletion from the reference, e.g. due to RNA splicing\n\n\n\n\n\n\nOP_SOFT_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence but stored\n\n\n\n\n\n\nOP_HARD_CLIP\n\n\ninsert\n\n\nsequence removed from the beginning or end of the query sequence and not stored\n\n\n\n\n\n\nOP_PAD\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_SEQ_MATCH\n\n\nmatch\n\n\nmatch operation with matching sequence positions\n\n\n\n\n\n\nOP_SEQ_MISMATCH\n\n\nmatch\n\n\nmatch operation with mismatching sequence positions\n\n\n\n\n\n\nOP_BACK\n\n\nspecial\n\n\nnot currently supported, but present for SAM/BAM compatibility\n\n\n\n\n\n\nOP_START\n\n\nspecial\n\n\nindicate the start of an alignment within the reference and query sequence\n\n\n\n\n\n\n\n\n\n\nAligned sequence\n\n\nA sequence aligned to another sequence is represented by the \nAlignedSequence\n type, which is a pair of the aligned sequence and an \nAlignment\n object.\n\n\nThe following example creates an aligned sequence object from a sequence and an alignment:\n\n\njulia\n AlignedSequence(  # pass an Alignment object\n           dna\nACGTAT\n,\n           Alignment([\n               AlignmentAnchor(0, 0, OP_START),\n               AlignmentAnchor(3, 3, OP_MATCH),\n               AlignmentAnchor(6, 3, OP_INSERT)\n           ])\n       )\n\u00b7\u00b7\u00b7---\nACGTAT\n\njulia\n AlignedSequence(  # or pass a vector of anchors\n           dna\nACGTAT\n,\n           [\n               AlignmentAnchor(0, 0, OP_START),\n               AlignmentAnchor(3, 3, OP_MATCH),\n               AlignmentAnchor(6, 3, OP_INSERT)\n           ]\n       )\n\u00b7\u00b7\u00b7---\nACGTAT\n\n\n\n\n\nIf you already have an aligned sequence with gap symbols, it can be converted to an \nAlignedSequence\n object by passing a reference sequence with it:\n\n\njulia\n \nseq\n \n=\n \ndna\nACGT--AAT--\n\n\n11nt DNA Sequence:\n\n\nACGT--AAT--\n\n\n\njulia\n \nref\n \n=\n \ndna\nACGTTTAT-GG\n\n\n11nt DNA Sequence:\n\n\nACGTTTAT-GG\n\n\n\njulia\n \nAlignedSequence\n(\nseq\n,\n \nref\n)\n\n\n\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7-\u00b7\u00b7\n\n\nACGT--AAT--\n\n\n\n\n\n\n\n\nOperating on alignments\n\n\n#\n\n\nBase.first\n \n \nFunction\n.\n\n\nfirst(coll)\n\n\n\n\n\nGet the first element of an iterable collection. Returns the start point of a \nRange\n even if it is empty.\n\n\nsource\n\n\n#\n\n\nBase.last\n \n \nFunction\n.\n\n\nlast(coll)\n\n\n\n\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \nendof\n to get the last index. Returns the end point of a \nRange\n even if it is empty.\n\n\nsource\n\n\n#\n\n\nBioAlignments.seq2ref\n \n \nFunction\n.\n\n\nseq2ref(aln, i)\n\n\n\n\n\nMap a position from sequence to reference.\n\n\nsource\n\n\n#\n\n\nBioAlignments.ref2seq\n \n \nFunction\n.\n\n\nref2seq(aln, i)\n\n\n\n\n\nMap a position from reference to sequence.\n\n\nsource\n\n\n#\n\n\nBioAlignments.cigar\n \n \nFunction\n.\n\n\ncigar(aln::Alignment)\n\n\n\n\n\nMake a CIGAR string encoding of \naln\n.\n\n\nThis is not entirely lossless as it discards the alignments start positions.\n\n\nsource", 
            "title": "Alignments"
        }, 
        {
            "location": "/alignments/#sequence-alignments", 
            "text": "The  BioAlignments  module contains tools for computing and working with sequence alignments.", 
            "title": "Sequence Alignments"
        }, 
        {
            "location": "/alignments/#representing-alignments", 
            "text": "The  Alignment  type can represent a wide variety of global or local sequence alignments while facilitating efficient coordinate transformation.  Alignment are always relative to a possibly unspecified reference sequence and represent a series of  edit operations  performed on that reference to transform it to the query sequence.  To represent an alignment we use a series of \"anchors\" stored in the  AlignmentAnchor  type. Anchors are form of run-length encoding alignment operations, but rather than store an operation along with a length, we store the end-point of that operation in both reference and query coordinates.  immutable   AlignmentAnchor \n     seqpos :: Int \n     refpos :: Int \n     op :: Operation  end   Every alignment starts with a special  OP_START  operation which is used to give the position in the reference and query prior to the start of the alignment, or 0, if the alignment starts at position 1.  For example, consider the following alignment:                0   4        9  12 15     19\n              |   |        |  |  |      |\n    query:     TGGC----ATCATTTAACG---CAAG\nreference: AGGGTGGCATTTATCAG---ACGTTTCGAGAC\n              |   |   |    |     |  |   |\n              4   8   12   17    20 23  27  Using anchors we would represent this as the following series of anchors:  [ \n     AlignmentAnchor (   0 ,    4 ,   OP_START ), \n     AlignmentAnchor (   4 ,    8 ,   OP_MATCH ), \n     AlignmentAnchor (   4 ,   12 ,   OP_DELETE ), \n     AlignmentAnchor (   9 ,   17 ,   OP_MATCH ), \n     AlignmentAnchor ( 12 ,   17 ,   OP_INSERT ), \n     AlignmentAnchor ( 15 ,   20 ,   OP_MATCH ), \n     AlignmentAnchor ( 15 ,   23 ,   OP_DELETE ), \n     AlignmentAnchor ( 19 ,   27 ,   OP_MATCH )  ]   An  Alignment  object can be created from a series of anchors:  julia  Alignment([\n           AlignmentAnchor(0,  4, OP_START),\n           AlignmentAnchor(4,  8, OP_MATCH),\n           AlignmentAnchor(4, 12, OP_DELETE)\n       ])\nBioAlignments.Alignment:\n  aligned range:\n    seq: 0-4\n    ref: 4-12\n  CIGAR string: 4M4D", 
            "title": "Representing alignments"
        }, 
        {
            "location": "/alignments/#operations", 
            "text": "Alignment operations follow closely from those used in the  SAM/BAM format  and are stored in the  Operation  bitstype.     Operation  Operation Type  Description      OP_MATCH  match  non-specific match    OP_INSERT  insert  insertion into reference sequence    OP_DELETE  delete  deletion from reference sequence    OP_SKIP  delete  (typically long) deletion from the reference, e.g. due to RNA splicing    OP_SOFT_CLIP  insert  sequence removed from the beginning or end of the query sequence but stored    OP_HARD_CLIP  insert  sequence removed from the beginning or end of the query sequence and not stored    OP_PAD  special  not currently supported, but present for SAM/BAM compatibility    OP_SEQ_MATCH  match  match operation with matching sequence positions    OP_SEQ_MISMATCH  match  match operation with mismatching sequence positions    OP_BACK  special  not currently supported, but present for SAM/BAM compatibility    OP_START  special  indicate the start of an alignment within the reference and query sequence", 
            "title": "Operations"
        }, 
        {
            "location": "/alignments/#aligned-sequence", 
            "text": "A sequence aligned to another sequence is represented by the  AlignedSequence  type, which is a pair of the aligned sequence and an  Alignment  object.  The following example creates an aligned sequence object from a sequence and an alignment:  julia  AlignedSequence(  # pass an Alignment object\n           dna ACGTAT ,\n           Alignment([\n               AlignmentAnchor(0, 0, OP_START),\n               AlignmentAnchor(3, 3, OP_MATCH),\n               AlignmentAnchor(6, 3, OP_INSERT)\n           ])\n       )\n\u00b7\u00b7\u00b7---\nACGTAT\n\njulia  AlignedSequence(  # or pass a vector of anchors\n           dna ACGTAT ,\n           [\n               AlignmentAnchor(0, 0, OP_START),\n               AlignmentAnchor(3, 3, OP_MATCH),\n               AlignmentAnchor(6, 3, OP_INSERT)\n           ]\n       )\n\u00b7\u00b7\u00b7---\nACGTAT  If you already have an aligned sequence with gap symbols, it can be converted to an  AlignedSequence  object by passing a reference sequence with it:  julia   seq   =   dna ACGT--AAT--  11nt DNA Sequence:  ACGT--AAT--  julia   ref   =   dna ACGTTTAT-GG  11nt DNA Sequence:  ACGTTTAT-GG  julia   AlignedSequence ( seq ,   ref )  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7-\u00b7\u00b7  ACGT--AAT--", 
            "title": "Aligned sequence"
        }, 
        {
            "location": "/alignments/#operating-on-alignments", 
            "text": "#  Base.first     Function .  first(coll)  Get the first element of an iterable collection. Returns the start point of a  Range  even if it is empty.  source  #  Base.last     Function .  last(coll)  Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling  endof  to get the last index. Returns the end point of a  Range  even if it is empty.  source  #  BioAlignments.seq2ref     Function .  seq2ref(aln, i)  Map a position from sequence to reference.  source  #  BioAlignments.ref2seq     Function .  ref2seq(aln, i)  Map a position from reference to sequence.  source  #  BioAlignments.cigar     Function .  cigar(aln::Alignment)  Make a CIGAR string encoding of  aln .  This is not entirely lossless as it discards the alignments start positions.  source", 
            "title": "Operating on alignments"
        }, 
        {
            "location": "/pairalign/", 
            "text": "Pairwise Alignemnt\n\n\n\n\nOverview\n\n\nPairwise alignment is a sequence alignment between two sequences. BioAlignments.jl implements several pairwise alignment algorithms that maximize alignment score or minimize alignment cost.\n\n\nGenerally, a pairwise alignment problem has two factors: an alignment type and a score/cost model. The alignment type specifies the alignment range (e.g. global, local, etc.) and the score/cost model specifies parameters of the alignment operations.\n\n\npairalign\n is a funtion to run alignment, which is exported from the \nBioAlignments\n module.  It takes an alignment type as its first argument, then two sequences to align, and finally a score model. Currently, the following four types of alignments are supported:\n\n\n\n\nGlobalAlignment\n: global-to-global alignment\n\n\nSemiGlobalAlignment\n: local-to-global alignment\n\n\nLocalAlignment\n: local-to-local alignment\n\n\nOverlapAlignment\n: end-free alignment\n\n\n\n\nFor scoring model, \nAffineGapScoreModel\n is currently supported. It imposes an \naffine gap penalty\n for insertions and deletions: \ngap_open + k * gap_extend\n for a consecutive insertion/deletion of length \nk\n. The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting \ngap_extend = 0\n or \ngap_open = 0\n, they are equivalent to the constant or linear gap penalty, respectively. The first argument of \nAffineGapScoreModel\n can be a substitution matrix like \nAffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1)\n. For details on substitution matrices, see the \nSubstitution matrices\n section.\n\n\nAlignment type can also be a distance of two sequences:\n\n\n\n\nEditDistance\n\n\nLevenshteinDistance\n\n\nHammingDistance\n\n\n\n\nIn this alignment, \nCostModel\n is used instead of \nAffineGapScoreModel\n to define cost of substitution, insertion, and deletion:\n\n\njulia\n \ncostmodel\n \n=\n \nCostModel\n(\nmatch\n=\n0\n,\n \nmismatch\n=\n1\n,\n \ninsertion\n=\n1\n,\n \ndeletion\n=\n1\n);\n\n\n\njulia\n \npairalign\n(\nEditDistance\n(),\n \nabcd\n,\n \nadcde\n,\n \ncostmodel\n)\n\n\nBio.Align.PairwiseAlignmentResult{Int64,String,String}:\n\n\n  distance: 2\n\n\n  seq: 1 abcd- 4\n\n\n         | ||\n\n\n  ref: 1 adcde 5\n\n\n\n\n\n\n\n\nOperations on pairwise alignment\n\n\npairalign\n returns a \nPairwiseAlignmentResult\n object and some accessors are provided for it.\n\n\n#\n\n\nBioAlignments.score\n \n \nFunction\n.\n\n\nscore(alignment_result)\n\n\n\n\n\nReturn score of alignment.\n\n\nsource\n\n\n#\n\n\nBioCore.distance\n \n \nFunction\n.\n\n\ndistance(alignment_result)\n\n\n\n\n\nRetrun distance of alignment.\n\n\nsource\n\n\n#\n\n\nBioAlignments.hasalignment\n \n \nFunction\n.\n\n\nhasalignment(alignment_result)\n\n\n\n\n\nCheck if alignment is stored or not.\n\n\nsource\n\n\n#\n\n\nBioAlignments.alignment\n \n \nFunction\n.\n\n\nalignment(alignment_result)\n\n\n\n\n\nReturn alignment if any.\n\n\nSee also: \nhasalignment\n\n\nsource\n\n\nPairwise alignment also implements some useful operations on it.\n\n\n#\n\n\nBioAlignments.count_matches\n \n \nFunction\n.\n\n\ncount_matches(aln)\n\n\n\n\n\nCount the number of matching positions.\n\n\nsource\n\n\n#\n\n\nBioAlignments.count_mismatches\n \n \nFunction\n.\n\n\ncount_mismatches(aln)\n\n\n\n\n\nCount the number of mismatching positions.\n\n\nsource\n\n\n#\n\n\nBioAlignments.count_insertions\n \n \nFunction\n.\n\n\ncount_insertions(aln)\n\n\n\n\n\nCount the number of inserting positions.\n\n\nsource\n\n\n#\n\n\nBioAlignments.count_deletions\n \n \nFunction\n.\n\n\ncount_deletions(aln)\n\n\n\n\n\nCount the number of deleting positions.\n\n\nsource\n\n\n#\n\n\nBioAlignments.count_aligned\n \n \nFunction\n.\n\n\ncount_aligned(aln)\n\n\n\n\n\nCount the number of aligned positions.\n\n\nsource\n\n\nThe example below shows a use case of these operations:\n\n\njulia\n \ns1\n \n=\n \ndna\nCCTAGGAGGG\n;\n\n\n\njulia\n \ns2\n \n=\n \ndna\nACCTGGTATGATAGCG\n;\n\n\n\njulia\n \nscoremodel\n \n=\n \nAffineGapScoreModel\n(\nEDNAFULL\n,\n \ngap_open\n=-\n5\n,\n \ngap_extend\n=-\n1\n);\n\n\n\njulia\n \nres\n \n=\n \npairalign\n(\nGlobalAlignment\n(),\n \ns1\n,\n \ns2\n,\n \nscoremodel\n)\n  \n# run pairwise alignment\n\n\nBio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  score: 13\n\n\n  seq:  0 -CCTAGG------AGGG 10\n\n\n           ||| ||      || |\n\n\n  ref:  1 ACCT-GGTATGATAGCG 16\n\n\n\n\njulia\n \nscore\n(\nres\n)\n  \n# get the achieved score of this alignment\n\n\n13\n\n\n\njulia\n \naln\n \n=\n \nalignment\n(\nres\n)\n\n\nPairwiseAlignment{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:\n\n\n  seq:  0 -CCTAGG------AGGG 10\n\n\n           ||| ||      || |\n\n\n  ref:  1 ACCT-GGTATGATAGCG 16\n\n\n\n\njulia\n \ncount_matches\n(\naln\n)\n\n\n8\n\n\n\njulia\n \ncount_mismatches\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_insertions\n(\naln\n)\n\n\n1\n\n\n\njulia\n \ncount_deletions\n(\naln\n)\n\n\n7\n\n\n\njulia\n \ncount_aligned\n(\naln\n)\n\n\n17\n\n\n\njulia\n \ncollect\n(\naln\n)\n  \n# pairwise alignment is iterable\n\n\n17-element Array{Tuple{Bio.Seq.DNA,Bio.Seq.DNA},1}:\n\n\n (-,A)\n\n\n (C,C)\n\n\n (C,C)\n\n\n (T,T)\n\n\n (A,-)\n\n\n (G,G)\n\n\n (G,G)\n\n\n (-,T)\n\n\n (-,A)\n\n\n (-,T)\n\n\n (-,G)\n\n\n (-,A)\n\n\n (-,T)\n\n\n (A,A)\n\n\n (G,G)\n\n\n (G,C)\n\n\n (G,G)\n\n\n\njulia\n \nDNASequence\n([\nx\n \nfor\n \n(\nx\n,\n \n_\n)\n \nin\n \naln\n])\n  \n# create aligned `s1` with gaps\n\n\n17nt DNA Sequence:\n\n\n-CCTAGG------AGGG\n\n\n\njulia\n \nDNASequence\n([\ny\n \nfor\n \n(\n_\n,\n \ny\n)\n \nin\n \naln\n])\n  \n# create aligned `s2` with gaps\n\n\n17nt DNA Sequence:\n\n\nACCT-GGTATGATAGCG\n\n\n\n\n\n\n\n\nSubstitution matrices\n\n\nA substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of \nsubmat\n from \nx\n to \ny\n can be obtained by writing \nsubmat[x,y]\n. In \nBio.Align\n, \nSubstitutionMatrix\n and \nDichotomousSubstitutionMatrix\n are two distinct types representing substitution matrices.\n\n\nSubstitutionMatrix\n is a general substitution matrix type that is a thin wrapper of regular matrix.\n\n\nSome common substitution matrices are provided. For DNA and RNA, \nEDNAFULL\n is defined:\n\n\njulia\n \nEDNAFULL\n\n\nBio.Align.SubstitutionMatrix{Bio.Seq.DNA,Int64}:\n\n\n     A  C  G  T  M  R  W  S  Y  K  V  H  D  B  N\n\n\n  A  5 -4 -4 -4  1  1  1 -4 -4 -4 -1 -1 -1 -4 -2\n\n\n  C -4  5 -4 -4  1 -4 -4  1  1 -4 -1 -1 -4 -1 -2\n\n\n  G -4 -4  5 -4 -4  1 -4  1 -4  1 -1 -4 -1 -1 -2\n\n\n  T -4 -4 -4  5 -4 -4  1 -4  1  1 -4 -1 -1 -1 -2\n\n\n  M  1  1 -4 -4 -1 -2 -2 -2 -2 -4 -1 -1 -3 -3 -1\n\n\n  R  1 -4  1 -4 -2 -1 -2 -2 -4 -2 -1 -3 -1 -3 -1\n\n\n  W  1 -4 -4  1 -2 -2 -1 -4 -2 -2 -3 -1 -1 -3 -1\n\n\n  S -4  1  1 -4 -2 -2 -4 -1 -2 -2 -1 -3 -3 -1 -1\n\n\n  Y -4  1 -4  1 -2 -4 -2 -2 -1 -2 -3 -1 -3 -1 -1\n\n\n  K -4 -4  1  1 -4 -2 -2 -2 -2 -1 -3 -3 -1 -1 -1\n\n\n  V -1 -1 -1 -4 -1 -1 -3 -1 -3 -3 -1 -2 -2 -2 -1\n\n\n  H -1 -1 -4 -1 -1 -3 -1 -3 -1 -3 -2 -1 -2 -2 -1\n\n\n  D -1 -4 -1 -1 -3 -1 -1 -3 -3 -1 -2 -2 -1 -2 -1\n\n\n  B -4 -1 -1 -1 -3 -3 -3 -1 -1 -1 -2 -2 -2 -1 -1\n\n\n  N -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n\n\n(underlined values are default ones)\n\n\n\n\n\n\nFor amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:\n\n\njulia\n \nBLOSUM62\n\n\nBio.Align.SubstitutionMatrix{Bio.Seq.AminoAcid,Int64}:\n\n\n     A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  O  U  B  J  Z  X  *\n\n\n  A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0  0\u0332  0\u0332 -2  0\u0332 -1  0 -4\n\n\n  R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3  0\u0332  0\u0332 -1  0\u0332  0 -1 -4\n\n\n  N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  0\u0332  0\u0332  3  0\u0332  0 -1 -4\n\n\n  D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4\n\n\n  C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1  0\u0332  0\u0332 -3  0\u0332 -3 -2 -4\n\n\n  Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0\u0332  0\u0332  0  0\u0332  3 -1 -4\n\n\n  E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4\n\n\n  G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3  0\u0332  0\u0332 -1  0\u0332 -2 -1 -4\n\n\n  H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0\u0332  0\u0332  0  0\u0332  0 -1 -4\n\n\n  I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4\n\n\n  L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1  0\u0332  0\u0332 -4  0\u0332 -3 -1 -4\n\n\n  K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  1 -1 -4\n\n\n  M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1  0\u0332  0\u0332 -3  0\u0332 -1 -1 -4\n\n\n  F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4\n\n\n  P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2  0\u0332  0\u0332 -2  0\u0332 -1 -2 -4\n\n\n  S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  0  0 -4\n\n\n  T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0  0\u0332  0\u0332 -1  0\u0332 -1  0 -4\n\n\n  W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3  0\u0332  0\u0332 -4  0\u0332 -3 -2 -4\n\n\n  Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4\n\n\n  V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4\n\n\n  O  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  U  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4\n\n\n  J  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332\n\n\n  Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4\n\n\n  X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1  0\u0332  0\u0332 -1  0\u0332 -1 -1 -4\n\n\n  * -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  0\u0332  0\u0332 -4  0\u0332 -4 -4  1\n\n\n(underlined values are default ones)\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix\n\n\nConstants\n\n\n\n\n\n\n\n\n\n\nPAM\n\n\nPAM30\n, \nPAM70\n, \nPAM250\n\n\n\n\n\n\nBLOSUM\n\n\nBLOSUM45\n, \nBLOSUM50\n, \nBLOSUM62\n, \nBLOSUM80\n, \nBLOSUM90\n\n\n\n\n\n\n\n\nThese matrices are downloaded from: \nftp://ftp.ncbi.nih.gov/blast/matrices/\n.\n\n\nSubstitutionMatrix\n can be modified like a regular matrix:\n\n\njulia\n \nmysubmat\n \n=\n \ncopy\n(\nBLOSUM62\n);\n  \n# create a copy\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# score of AA_A =\n AA_R substitution is -1\n\n\n-1\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n \n=\n \n-\n3\n  \n# set the score to -3\n\n\n-3\n\n\n\njulia\n \nmysubmat\n[\nAA_A\n,\nAA_R\n]\n  \n# the score is modified\n\n\n-3\n\n\n\n\n\n\nMake sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case, \nBLOSUM62\n is shared in the whole program and modification on it will affect any result that uses \nBLOSUM62\n.\n\n\nDichotomousSubstitutionMatrix\n is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than \nSubstitutionMatrix\n.\n\n\njulia\n \nsubmat\n \n=\n \nDichotomousSubstitutionMatrix\n(\n1\n,\n \n-\n1\n)\n\n\nBio.Align.DichotomousSubstitutionMatrix{Int64}:\n\n\n     match =  1\n\n\n  mismatch = -1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nA\n]\n  \n# match\n\n\n1\n\n\n\njulia\n \nsubmat\n[\nA\n,\nB\n]\n  \n# mismatch\n\n\n-1", 
            "title": "Pairwise alignment"
        }, 
        {
            "location": "/pairalign/#pairwise-alignemnt", 
            "text": "", 
            "title": "Pairwise Alignemnt"
        }, 
        {
            "location": "/pairalign/#overview", 
            "text": "Pairwise alignment is a sequence alignment between two sequences. BioAlignments.jl implements several pairwise alignment algorithms that maximize alignment score or minimize alignment cost.  Generally, a pairwise alignment problem has two factors: an alignment type and a score/cost model. The alignment type specifies the alignment range (e.g. global, local, etc.) and the score/cost model specifies parameters of the alignment operations.  pairalign  is a funtion to run alignment, which is exported from the  BioAlignments  module.  It takes an alignment type as its first argument, then two sequences to align, and finally a score model. Currently, the following four types of alignments are supported:   GlobalAlignment : global-to-global alignment  SemiGlobalAlignment : local-to-global alignment  LocalAlignment : local-to-local alignment  OverlapAlignment : end-free alignment   For scoring model,  AffineGapScoreModel  is currently supported. It imposes an  affine gap penalty  for insertions and deletions:  gap_open + k * gap_extend  for a consecutive insertion/deletion of length  k . The affine gap penalty is flexible enough to create a constant and linear scoring model. Setting  gap_extend = 0  or  gap_open = 0 , they are equivalent to the constant or linear gap penalty, respectively. The first argument of  AffineGapScoreModel  can be a substitution matrix like  AffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1) . For details on substitution matrices, see the  Substitution matrices  section.  Alignment type can also be a distance of two sequences:   EditDistance  LevenshteinDistance  HammingDistance   In this alignment,  CostModel  is used instead of  AffineGapScoreModel  to define cost of substitution, insertion, and deletion:  julia   costmodel   =   CostModel ( match = 0 ,   mismatch = 1 ,   insertion = 1 ,   deletion = 1 );  julia   pairalign ( EditDistance (),   abcd ,   adcde ,   costmodel )  Bio.Align.PairwiseAlignmentResult{Int64,String,String}:    distance: 2    seq: 1 abcd- 4           | ||    ref: 1 adcde 5", 
            "title": "Overview"
        }, 
        {
            "location": "/pairalign/#operations-on-pairwise-alignment", 
            "text": "pairalign  returns a  PairwiseAlignmentResult  object and some accessors are provided for it.  #  BioAlignments.score     Function .  score(alignment_result)  Return score of alignment.  source  #  BioCore.distance     Function .  distance(alignment_result)  Retrun distance of alignment.  source  #  BioAlignments.hasalignment     Function .  hasalignment(alignment_result)  Check if alignment is stored or not.  source  #  BioAlignments.alignment     Function .  alignment(alignment_result)  Return alignment if any.  See also:  hasalignment  source  Pairwise alignment also implements some useful operations on it.  #  BioAlignments.count_matches     Function .  count_matches(aln)  Count the number of matching positions.  source  #  BioAlignments.count_mismatches     Function .  count_mismatches(aln)  Count the number of mismatching positions.  source  #  BioAlignments.count_insertions     Function .  count_insertions(aln)  Count the number of inserting positions.  source  #  BioAlignments.count_deletions     Function .  count_deletions(aln)  Count the number of deleting positions.  source  #  BioAlignments.count_aligned     Function .  count_aligned(aln)  Count the number of aligned positions.  source  The example below shows a use case of these operations:  julia   s1   =   dna CCTAGGAGGG ;  julia   s2   =   dna ACCTGGTATGATAGCG ;  julia   scoremodel   =   AffineGapScoreModel ( EDNAFULL ,   gap_open =- 5 ,   gap_extend =- 1 );  julia   res   =   pairalign ( GlobalAlignment (),   s1 ,   s2 ,   scoremodel )    # run pairwise alignment  Bio.Align.PairwiseAlignmentResult{Int64,Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    score: 13    seq:  0 -CCTAGG------AGGG 10             ||| ||      || |    ref:  1 ACCT-GGTATGATAGCG 16  julia   score ( res )    # get the achieved score of this alignment  13  julia   aln   =   alignment ( res )  PairwiseAlignment{Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}},Bio.Seq.BioSequence{Bio.Seq.DNAAlphabet{4}}}:    seq:  0 -CCTAGG------AGGG 10             ||| ||      || |    ref:  1 ACCT-GGTATGATAGCG 16  julia   count_matches ( aln )  8  julia   count_mismatches ( aln )  1  julia   count_insertions ( aln )  1  julia   count_deletions ( aln )  7  julia   count_aligned ( aln )  17  julia   collect ( aln )    # pairwise alignment is iterable  17-element Array{Tuple{Bio.Seq.DNA,Bio.Seq.DNA},1}:   (-,A)   (C,C)   (C,C)   (T,T)   (A,-)   (G,G)   (G,G)   (-,T)   (-,A)   (-,T)   (-,G)   (-,A)   (-,T)   (A,A)   (G,G)   (G,C)   (G,G)  julia   DNASequence ([ x   for   ( x ,   _ )   in   aln ])    # create aligned `s1` with gaps  17nt DNA Sequence:  -CCTAGG------AGGG  julia   DNASequence ([ y   for   ( _ ,   y )   in   aln ])    # create aligned `s2` with gaps  17nt DNA Sequence:  ACCT-GGTATGATAGCG", 
            "title": "Operations on pairwise alignment"
        }, 
        {
            "location": "/pairalign/#substitution-matrices", 
            "text": "A substitution matrix is a function of substitution score (or cost) from one symbol to other. Substitution value of  submat  from  x  to  y  can be obtained by writing  submat[x,y] . In  Bio.Align ,  SubstitutionMatrix  and  DichotomousSubstitutionMatrix  are two distinct types representing substitution matrices.  SubstitutionMatrix  is a general substitution matrix type that is a thin wrapper of regular matrix.  Some common substitution matrices are provided. For DNA and RNA,  EDNAFULL  is defined:  julia   EDNAFULL  Bio.Align.SubstitutionMatrix{Bio.Seq.DNA,Int64}:       A  C  G  T  M  R  W  S  Y  K  V  H  D  B  N    A  5 -4 -4 -4  1  1  1 -4 -4 -4 -1 -1 -1 -4 -2    C -4  5 -4 -4  1 -4 -4  1  1 -4 -1 -1 -4 -1 -2    G -4 -4  5 -4 -4  1 -4  1 -4  1 -1 -4 -1 -1 -2    T -4 -4 -4  5 -4 -4  1 -4  1  1 -4 -1 -1 -1 -2    M  1  1 -4 -4 -1 -2 -2 -2 -2 -4 -1 -1 -3 -3 -1    R  1 -4  1 -4 -2 -1 -2 -2 -4 -2 -1 -3 -1 -3 -1    W  1 -4 -4  1 -2 -2 -1 -4 -2 -2 -3 -1 -1 -3 -1    S -4  1  1 -4 -2 -2 -4 -1 -2 -2 -1 -3 -3 -1 -1    Y -4  1 -4  1 -2 -4 -2 -2 -1 -2 -3 -1 -3 -1 -1    K -4 -4  1  1 -4 -2 -2 -2 -2 -1 -3 -3 -1 -1 -1    V -1 -1 -1 -4 -1 -1 -3 -1 -3 -3 -1 -2 -2 -2 -1    H -1 -1 -4 -1 -1 -3 -1 -3 -1 -3 -2 -1 -2 -2 -1    D -1 -4 -1 -1 -3 -1 -1 -3 -3 -1 -2 -2 -1 -2 -1    B -4 -1 -1 -1 -3 -3 -3 -1 -1 -1 -2 -2 -2 -1 -1    N -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  (underlined values are default ones)   For amino acids, PAM (Point Accepted Mutation) and BLOSUM (BLOcks SUbstitution Matrix) matrices are defined:  julia   BLOSUM62  Bio.Align.SubstitutionMatrix{Bio.Seq.AminoAcid,Int64}:       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  O  U  B  J  Z  X  *    A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0  0\u0332  0\u0332 -2  0\u0332 -1  0 -4    R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3  0\u0332  0\u0332 -1  0\u0332  0 -1 -4    N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  0\u0332  0\u0332  3  0\u0332  0 -1 -4    D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4    C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1  0\u0332  0\u0332 -3  0\u0332 -3 -2 -4    Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0\u0332  0\u0332  0  0\u0332  3 -1 -4    E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4    G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3  0\u0332  0\u0332 -1  0\u0332 -2 -1 -4    H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0\u0332  0\u0332  0  0\u0332  0 -1 -4    I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4    L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1  0\u0332  0\u0332 -4  0\u0332 -3 -1 -4    K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  1 -1 -4    M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1  0\u0332  0\u0332 -3  0\u0332 -1 -1 -4    F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1  0\u0332  0\u0332 -3  0\u0332 -3 -1 -4    P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2  0\u0332  0\u0332 -2  0\u0332 -1 -2 -4    S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0\u0332  0\u0332  0  0\u0332  0  0 -4    T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0  0\u0332  0\u0332 -1  0\u0332 -1  0 -4    W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3  0\u0332  0\u0332 -4  0\u0332 -3 -2 -4    Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4    V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4  0\u0332  0\u0332 -3  0\u0332 -2 -1 -4    O  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    U  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  0\u0332  0\u0332  4  0\u0332  1 -1 -4    J  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332  0\u0332    Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  0\u0332  0\u0332  1  0\u0332  4 -1 -4    X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1  0\u0332  0\u0332 -1  0\u0332 -1 -1 -4    * -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  0\u0332  0\u0332 -4  0\u0332 -4 -4  1  (underlined values are default ones)      Matrix  Constants      PAM  PAM30 ,  PAM70 ,  PAM250    BLOSUM  BLOSUM45 ,  BLOSUM50 ,  BLOSUM62 ,  BLOSUM80 ,  BLOSUM90     These matrices are downloaded from:  ftp://ftp.ncbi.nih.gov/blast/matrices/ .  SubstitutionMatrix  can be modified like a regular matrix:  julia   mysubmat   =   copy ( BLOSUM62 );    # create a copy  julia   mysubmat [ AA_A , AA_R ]    # score of AA_A =  AA_R substitution is -1  -1  julia   mysubmat [ AA_A , AA_R ]   =   - 3    # set the score to -3  -3  julia   mysubmat [ AA_A , AA_R ]    # the score is modified  -3   Make sure to create a copy of the original matrix when you create a matrix from a predefined matrix. In the above case,  BLOSUM62  is shared in the whole program and modification on it will affect any result that uses  BLOSUM62 .  DichotomousSubstitutionMatrix  is a specialized matrix for matching or mismatching substitution.  This is a preferable choice when performance is more important than flexibility because looking up score is faster than  SubstitutionMatrix .  julia   submat   =   DichotomousSubstitutionMatrix ( 1 ,   - 1 )  Bio.Align.DichotomousSubstitutionMatrix{Int64}:       match =  1    mismatch = -1  julia   submat [ A , A ]    # match  1  julia   submat [ A , B ]    # mismatch  -1", 
            "title": "Substitution matrices"
        }, 
        {
            "location": "/hts-files/", 
            "text": "High-throughput Sequencing\n\n\n\n\nOverview\n\n\nHigh-throughput sequencing (HTS) technologies generate a large amount of data in the form of a large number of nucleotide sequencing reads. One of the most common tasks in bioinformatics is to align these reads against known reference genomes, chromosomes, or contigs. The \nBioAlignments\n module provides several data formats commonly used for this kind of task.\n\n\n\n\nSAM and BAM file formats\n\n\nSAM and BAM are the most popular file formats and have the same reading and writing interface as all other formats in Bio.jl. A typical code iterating over all records in a file looks like below:\n\n\n# import the SAM and BAM module\n\n\nusing\n \nBioAlignments\n\n\n\n# open a BAM file\n\n\nreader\n \n=\n \nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n\n\n\n# iterate over BAM records\n\n\nfor\n \nrecord\n \nin\n \nreader\n\n    \n# `record` is a BAM.Record object\n\n    \nif\n \nBAM\n.\nismapped\n(\nrecord\n)\n\n        \n# print mapped position\n\n        \nprintln\n(\nBAM\n.\nrefname\n(\nrecord\n),\n \n:\n,\n \nBAM\n.\nposition\n(\nrecord\n))\n\n    \nend\n\n\nend\n\n\n\n# close the BAM file\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\nAccessor functions are defined in \nSAM\n and \nBAM\n modules.  Lists of these functions to \nSAM.Record\n and \nBAM.Record\n are described in \nSAM\n and \nBAM\n sections, respectively.\n\n\nSAM.Reader\n and \nBAM.Reader\n implement the \nheader\n function, which returns a \nSAM.Header\n object. This is conceptually a sequence of \nSAM.MetaInfo\n objects corresponding to header lines that start with '@' markers. To select \nSAM.MetaInfo\n records with a specific tag, you can use the \nfind\n function:\n\n\njulia\n \nreader\n \n=\n \nopen\n(\nSAM\n.\nReader\n,\n \ndata.sam\n);\n\n\n\njulia\n \nfind\n(\nheader\n(\nreader\n),\n \nSQ\n)\n\n\n7-element Array{Bio.Align.SAM.MetaInfo,1}:\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr1 LN=30427671\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr2 LN=19698289\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr3 LN=23459830\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr4 LN=18585056\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=Chr5 LN=26975502\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=chloroplast LN=154478\n\n\n Bio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=mitochondria LN=366924\n\n\n\n\n\n\nA \nSAM.MetaInfo\n object can be created as follows:\n\n\njulia\n \nSAM\n.\nMetaInfo\n(\nSQ\n,\n \n[\nSN\n \n=\n \nchr1\n,\n \nLN\n \n=\n \n1234\n])\n\n\nBio.Align.SAM.MetaInfo:\n\n\n    tag: SQ\n\n\n  value: SN=chr1 LN=1234\n\n\n\njulia\n \nSAM\n.\nMetaInfo\n(\nCO\n,\n \ncomment\n)\n\n\nBio.Align.SAM.MetaInfo:\n\n\n    tag: CO\n\n\n  value: comment\n\n\n\n\n\n\n\n\nGetting records in a range\n\n\nBioAlignments.jl supports the BAI index to fetch records in a specific range from a BAM file.  \nSamtools\n provides \nindex\n subcommand to create an index file (.bai) from a sorted BAM file.\n\n\n$\n samtools index -b SRR1238088.sort.bam\n\n$\n ls SRR1238088.sort.bam*\n\nSRR1238088.sort.bam     SRR1238088.sort.bam.bai\n\n\n\n\n\n\neachoverlap(reader, chrom, range)\n returns an iterator of BAM records overlapping the query interval:\n\n\nreader\n \n=\n \nopen\n(\nBAM\n.\nReader\n,\n \nSRR1238088.sort.bam\n,\n \nindex\n=\nSRR1238088.sort.bam.bai\n)\n\n\nfor\n \nrecord\n \nin\n \neachoverlap\n(\nreader\n,\n \nChr2\n,\n \n10000\n:\n11000\n)\n\n    \n# `record` is a BAM.Record object\n\n    \n# ...\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\neachoverlap\n also supports \nInterval\n type definded in \nBioAlignments.jl\n.\n\n\n# Load GFF3 module.\n\n\nusing\n \nGenomicFeatures\n\n\n\n# Load genomic features from a GFF3 file.\n\n\nfeatures\n \n=\n \nopen\n(\ncollect\n,\n \nGFF3\n.\nReader\n,\n \nTAIR10_GFF3_genes.gff\n)\n\n\n\n# Keep mRNA features.\n\n\nfilter!\n(\nx\n \n-\n \nGFF3\n.\nfeaturetype\n(\nx\n)\n \n==\n \nmRNA\n,\n \nfeatures\n)\n\n\n\n# Load BAM module.\n\n\nusing\n \nBioAlignments\n\n\n\n# Open a BAM file and iterate over records overlapping mRNA transcripts.\n\n\nreader\n \n=\n \nopen\n(\nBAM\n.\nReader\n,\n \nSRR1238088.sort.bam\n,\n \nindex\n=\nSRR1238088.sort.bam.bai\n)\n\n\nfor\n \nfeature\n \nin\n \nfeatures\n\n    \nfor\n \nrecord\n \nin\n \neachoverlap\n(\nreader\n,\n \nfeature\n)\n\n        \n# `record` overlaps `feature`.\n\n        \n# ...\n\n    \nend\n\n\nend\n\n\nclose\n(\nreader\n)\n\n\n\n\n\n\n\n\nPerformance tips\n\n\nThe size of a BAM file is often extremely large. The iterator interface mentioned above allocates an object for each record and that may be a bottleneck of reading data from a BAM file. In-place reading reuses a preallocated object for every record and less memory allocation happens in reading:\n\n\nreader\n \n=\n \nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n\n\nrecord\n \n=\n \nBAM\n.\nRecord\n()\n\n\nwhile\n \n!\neof\n(\nreader\n)\n\n    \nread!\n(\nreader\n,\n \nrecord\n)\n\n    \n# do something\n\n\nend\n\n\n\n\n\n\nAccessing optional fields will results in type instability in Julia, which has a significant negative impact on performance. If the user knows the type of a value in advance, specifying it as a type annotation will alleviate the problem:\n\n\nfor\n \nrecord\n \nin\n \nopen\n(\nBAM\n.\nReader\n,\n \ndata.bam\n)\n\n    \nnm\n \n=\n \nrecord\n[\nNM\n]\n::\nUInt8\n\n    \n# do something\n\n\nend", 
            "title": "High-throughput sequencing"
        }, 
        {
            "location": "/hts-files/#high-throughput-sequencing", 
            "text": "", 
            "title": "High-throughput Sequencing"
        }, 
        {
            "location": "/hts-files/#overview", 
            "text": "High-throughput sequencing (HTS) technologies generate a large amount of data in the form of a large number of nucleotide sequencing reads. One of the most common tasks in bioinformatics is to align these reads against known reference genomes, chromosomes, or contigs. The  BioAlignments  module provides several data formats commonly used for this kind of task.", 
            "title": "Overview"
        }, 
        {
            "location": "/hts-files/#sam-and-bam-file-formats", 
            "text": "SAM and BAM are the most popular file formats and have the same reading and writing interface as all other formats in Bio.jl. A typical code iterating over all records in a file looks like below:  # import the SAM and BAM module  using   BioAlignments  # open a BAM file  reader   =   open ( BAM . Reader ,   data.bam )  # iterate over BAM records  for   record   in   reader \n     # `record` is a BAM.Record object \n     if   BAM . ismapped ( record ) \n         # print mapped position \n         println ( BAM . refname ( record ),   : ,   BAM . position ( record )) \n     end  end  # close the BAM file  close ( reader )   Accessor functions are defined in  SAM  and  BAM  modules.  Lists of these functions to  SAM.Record  and  BAM.Record  are described in  SAM  and  BAM  sections, respectively.  SAM.Reader  and  BAM.Reader  implement the  header  function, which returns a  SAM.Header  object. This is conceptually a sequence of  SAM.MetaInfo  objects corresponding to header lines that start with '@' markers. To select  SAM.MetaInfo  records with a specific tag, you can use the  find  function:  julia   reader   =   open ( SAM . Reader ,   data.sam );  julia   find ( header ( reader ),   SQ )  7-element Array{Bio.Align.SAM.MetaInfo,1}:   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr1 LN=30427671   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr2 LN=19698289   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr3 LN=23459830   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr4 LN=18585056   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=Chr5 LN=26975502   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=chloroplast LN=154478   Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=mitochondria LN=366924   A  SAM.MetaInfo  object can be created as follows:  julia   SAM . MetaInfo ( SQ ,   [ SN   =   chr1 ,   LN   =   1234 ])  Bio.Align.SAM.MetaInfo:      tag: SQ    value: SN=chr1 LN=1234  julia   SAM . MetaInfo ( CO ,   comment )  Bio.Align.SAM.MetaInfo:      tag: CO    value: comment", 
            "title": "SAM and BAM file formats"
        }, 
        {
            "location": "/hts-files/#getting-records-in-a-range", 
            "text": "BioAlignments.jl supports the BAI index to fetch records in a specific range from a BAM file.   Samtools  provides  index  subcommand to create an index file (.bai) from a sorted BAM file.  $  samtools index -b SRR1238088.sort.bam $  ls SRR1238088.sort.bam* SRR1238088.sort.bam     SRR1238088.sort.bam.bai   eachoverlap(reader, chrom, range)  returns an iterator of BAM records overlapping the query interval:  reader   =   open ( BAM . Reader ,   SRR1238088.sort.bam ,   index = SRR1238088.sort.bam.bai )  for   record   in   eachoverlap ( reader ,   Chr2 ,   10000 : 11000 ) \n     # `record` is a BAM.Record object \n     # ...  end  close ( reader )   eachoverlap  also supports  Interval  type definded in  BioAlignments.jl .  # Load GFF3 module.  using   GenomicFeatures  # Load genomic features from a GFF3 file.  features   =   open ( collect ,   GFF3 . Reader ,   TAIR10_GFF3_genes.gff )  # Keep mRNA features.  filter! ( x   -   GFF3 . featuretype ( x )   ==   mRNA ,   features )  # Load BAM module.  using   BioAlignments  # Open a BAM file and iterate over records overlapping mRNA transcripts.  reader   =   open ( BAM . Reader ,   SRR1238088.sort.bam ,   index = SRR1238088.sort.bam.bai )  for   feature   in   features \n     for   record   in   eachoverlap ( reader ,   feature ) \n         # `record` overlaps `feature`. \n         # ... \n     end  end  close ( reader )", 
            "title": "Getting records in a range"
        }, 
        {
            "location": "/hts-files/#performance-tips", 
            "text": "The size of a BAM file is often extremely large. The iterator interface mentioned above allocates an object for each record and that may be a bottleneck of reading data from a BAM file. In-place reading reuses a preallocated object for every record and less memory allocation happens in reading:  reader   =   open ( BAM . Reader ,   data.bam )  record   =   BAM . Record ()  while   ! eof ( reader ) \n     read! ( reader ,   record ) \n     # do something  end   Accessing optional fields will results in type instability in Julia, which has a significant negative impact on performance. If the user knows the type of a value in advance, specifying it as a type annotation will alleviate the problem:  for   record   in   open ( BAM . Reader ,   data.bam ) \n     nm   =   record [ NM ] :: UInt8 \n     # do something  end", 
            "title": "Performance tips"
        }, 
        {
            "location": "/io/bam/", 
            "text": "BAM\n\n\n\n\nDescription\n\n\nBAM is a binary counterpart of the \nSAM\n file format.\n\n\n\n\nReader type: \nBAM.Reader\n\n\nWriter type: \nBAM.Writer\n\n\nElement type: \nBAM.Record\n\n\n\n\nWhen writing data in the BAM file format, the underlying output stream needs to be wrapped with a \nBGZFStream\n object provided from \nBGZFStreams.jl\n.\n\n\n\n\nExamples\n\n\nTODO\n\n\n\n\nAccessors\n\n\n#\n\n\nBioAlignments.BAM.Reader\n \n \nType\n.\n\n\nBAM\n.\nReader\n(\ninput\n::\nIO\n;\n \nindex\n=\nnothing\n)\n\n\n\n\n\n\nCreate a data reader of the BAM file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\nindex=nothing\n: filepath to a random access index (currently \nbai\n is Supported)\n\n\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.header\n \n \nFunction\n.\n\n\nheader\n(\nreader\n::\nReader\n;\n \nfillSQ\n::\nBool\n=\nfalse\n)\n::\nSAM\n.\nHeader\n\n\n\n\n\n\nGet the header of \nreader\n.\n\n\nIf \nfillSQ\n is \ntrue\n, this function fills missing \"SQ\" metainfo in the header.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.Writer\n \n \nType\n.\n\n\nBAM.Writer(output::BGZFStream, header::SAM.Header)\n\n\n\n\n\nCreate a data writer of the BAM file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nheader\n: SAM header object\n\n\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.Record\n \n \nType\n.\n\n\nBAM.Record()\n\n\n\n\n\nCreate an unfilled BAM record.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.flag\n \n \nFunction\n.\n\n\nflag(record::Record)::UInt16\n\n\n\n\n\nGet the bitwise flag of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.ismapped\n \n \nFunction\n.\n\n\nismapped(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.isprimary\n \n \nFunction\n.\n\n\nisprimary(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is a primary line of the read.\n\n\nThis is equivalent to \nflag(record) \n 0x900 == 0\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.refid\n \n \nFunction\n.\n\n\nrefid(record::Record)::Int\n\n\n\n\n\nGet the reference sequence ID of \nrecord\n.\n\n\nThe ID is 1-based (i.e. the first sequence is 1) and is 0 for a record without a mapping position.\n\n\nSee also: \nBAM.rname\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.refname\n \n \nFunction\n.\n\n\nrefname(record::Record)::String\n\n\n\n\n\nGet the reference sequence name of \nrecord\n.\n\n\nSee also: \nBAM.refid\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.position\n \n \nFunction\n.\n\n\nposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based leftmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.rightposition\n \n \nFunction\n.\n\n\nrightposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based rightmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.isnextmapped\n \n \nFunction\n.\n\n\nisnextmapped(record::Record)::Bool\n\n\n\n\n\nTest if the mate/next read of \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.nextrefid\n \n \nFunction\n.\n\n\nnextrefid(record::Record)::Int\n\n\n\n\n\nGet the next/mate reference sequence ID of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.nextrefname\n \n \nFunction\n.\n\n\nnextrefname(record::Record)::String\n\n\n\n\n\nGet the reference name of the mate/next read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.nextposition\n \n \nFunction\n.\n\n\nnextposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based leftmost mapping position of the next/mate read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.mappingquality\n \n \nFunction\n.\n\n\nmappingquality(record::Record)::UInt8\n\n\n\n\n\nGet the mapping quality of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.cigar\n \n \nFunction\n.\n\n\ncigar(record::Record)::String\n\n\n\n\n\nGet the CIGAR string of \nrecord\n.\n\n\nSee also \nBAM.cigar_rle\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.cigar_rle\n \n \nFunction\n.\n\n\ncigar_rle(record::Record)::Tuple{Vector{BioAlignments.Operation},Vector{Int}}\n\n\n\n\n\nGet a run-length encoded tuple \n(ops, lens)\n of the CIGAR string in \nrecord\n.\n\n\nSee also \nBAM.cigar\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.alignment\n \n \nFunction\n.\n\n\nalignment(record::Record)::BioAlignments.Alignment\n\n\n\n\n\nGet the alignment of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.alignlength\n \n \nFunction\n.\n\n\nalignlength(record::Record)::Int\n\n\n\n\n\nGet the alignment length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.tempname\n \n \nFunction\n.\n\n\ntempname(record::Record)::String\n\n\n\n\n\nGet the query template name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.templength\n \n \nFunction\n.\n\n\ntemplength(record::Record)::Int\n\n\n\n\n\nGet the template length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.sequence\n \n \nFunction\n.\n\n\nsequence(record::Record)::BioSequences.DNASequence\n\n\n\n\n\nGet the segment sequence of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.seqlength\n \n \nFunction\n.\n\n\nseqlength(record::Record)::Int\n\n\n\n\n\nGet the sequence length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.quality\n \n \nFunction\n.\n\n\nquality(record::Record)::Vector{UInt8}\n\n\n\n\n\nGet the base quality of  \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.BAM.auxdata\n \n \nFunction\n.\n\n\nauxdata(record::Record)::BAM.AuxData\n\n\n\n\n\nGet the auxiliary data of \nrecord\n.\n\n\nsource", 
            "title": "SAM"
        }, 
        {
            "location": "/io/bam/#bam", 
            "text": "", 
            "title": "BAM"
        }, 
        {
            "location": "/io/bam/#description", 
            "text": "BAM is a binary counterpart of the  SAM  file format.   Reader type:  BAM.Reader  Writer type:  BAM.Writer  Element type:  BAM.Record   When writing data in the BAM file format, the underlying output stream needs to be wrapped with a  BGZFStream  object provided from  BGZFStreams.jl .", 
            "title": "Description"
        }, 
        {
            "location": "/io/bam/#examples", 
            "text": "TODO", 
            "title": "Examples"
        }, 
        {
            "location": "/io/bam/#accessors", 
            "text": "#  BioAlignments.BAM.Reader     Type .  BAM . Reader ( input :: IO ;   index = nothing )   Create a data reader of the BAM file format.  Arguments   input : data source  index=nothing : filepath to a random access index (currently  bai  is Supported)   source  #  BioAlignments.BAM.header     Function .  header ( reader :: Reader ;   fillSQ :: Bool = false ) :: SAM . Header   Get the header of  reader .  If  fillSQ  is  true , this function fills missing \"SQ\" metainfo in the header.  source  #  BioAlignments.BAM.Writer     Type .  BAM.Writer(output::BGZFStream, header::SAM.Header)  Create a data writer of the BAM file format.  Arguments   output : data sink  header : SAM header object   source  #  BioAlignments.BAM.Record     Type .  BAM.Record()  Create an unfilled BAM record.  source  #  BioAlignments.BAM.flag     Function .  flag(record::Record)::UInt16  Get the bitwise flag of  record .  source  #  BioAlignments.BAM.ismapped     Function .  ismapped(record::Record)::Bool  Test if  record  is mapped.  source  #  BioAlignments.BAM.isprimary     Function .  isprimary(record::Record)::Bool  Test if  record  is a primary line of the read.  This is equivalent to  flag(record)   0x900 == 0 .  source  #  BioAlignments.BAM.refid     Function .  refid(record::Record)::Int  Get the reference sequence ID of  record .  The ID is 1-based (i.e. the first sequence is 1) and is 0 for a record without a mapping position.  See also:  BAM.rname  source  #  BioAlignments.BAM.refname     Function .  refname(record::Record)::String  Get the reference sequence name of  record .  See also:  BAM.refid  source  #  BioAlignments.BAM.position     Function .  position(record::Record)::Int  Get the 1-based leftmost mapping position of  record .  source  #  BioAlignments.BAM.rightposition     Function .  rightposition(record::Record)::Int  Get the 1-based rightmost mapping position of  record .  source  #  BioAlignments.BAM.isnextmapped     Function .  isnextmapped(record::Record)::Bool  Test if the mate/next read of  record  is mapped.  source  #  BioAlignments.BAM.nextrefid     Function .  nextrefid(record::Record)::Int  Get the next/mate reference sequence ID of  record .  source  #  BioAlignments.BAM.nextrefname     Function .  nextrefname(record::Record)::String  Get the reference name of the mate/next read of  record .  source  #  BioAlignments.BAM.nextposition     Function .  nextposition(record::Record)::Int  Get the 1-based leftmost mapping position of the next/mate read of  record .  source  #  BioAlignments.BAM.mappingquality     Function .  mappingquality(record::Record)::UInt8  Get the mapping quality of  record .  source  #  BioAlignments.BAM.cigar     Function .  cigar(record::Record)::String  Get the CIGAR string of  record .  See also  BAM.cigar_rle .  source  #  BioAlignments.BAM.cigar_rle     Function .  cigar_rle(record::Record)::Tuple{Vector{BioAlignments.Operation},Vector{Int}}  Get a run-length encoded tuple  (ops, lens)  of the CIGAR string in  record .  See also  BAM.cigar .  source  #  BioAlignments.BAM.alignment     Function .  alignment(record::Record)::BioAlignments.Alignment  Get the alignment of  record .  source  #  BioAlignments.BAM.alignlength     Function .  alignlength(record::Record)::Int  Get the alignment length of  record .  source  #  BioAlignments.BAM.tempname     Function .  tempname(record::Record)::String  Get the query template name of  record .  source  #  BioAlignments.BAM.templength     Function .  templength(record::Record)::Int  Get the template length of  record .  source  #  BioAlignments.BAM.sequence     Function .  sequence(record::Record)::BioSequences.DNASequence  Get the segment sequence of  record .  source  #  BioAlignments.BAM.seqlength     Function .  seqlength(record::Record)::Int  Get the sequence length of  record .  source  #  BioAlignments.BAM.quality     Function .  quality(record::Record)::Vector{UInt8}  Get the base quality of   record .  source  #  BioAlignments.BAM.auxdata     Function .  auxdata(record::Record)::BAM.AuxData  Get the auxiliary data of  record .  source", 
            "title": "Accessors"
        }, 
        {
            "location": "/io/sam/", 
            "text": "SAM\n\n\n\n\nDescription\n\n\nSAM is a text-based file format for representing sequence alignments.\n\n\n\n\nReader type: \nSAM.Reader\n\n\nWriter type: \nSAM.Writer\n\n\nElement type: \nSAM.Record\n\n\n\n\nThis module provides 16-bit flags defined in the SAM specs:\n\n\n\n\n\n\n\n\nFlag\n\n\nBit\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSAM.FLAG_PAIRED\n\n\n0x0001\n\n\ntemplate having multiple segments in sequencing\n\n\n\n\n\n\nSAM.FLAG_PROPER_PAIR\n\n\n0x0002\n\n\neach segment properly aligned according to the aligner\n\n\n\n\n\n\nSAM.FLAG_UNMAP\n\n\n0x0004\n\n\nsegment unmapped\n\n\n\n\n\n\nSAM.FLAG_MUNMAP\n\n\n0x0008\n\n\nnext segment in the template unmapped\n\n\n\n\n\n\nSAM.FLAG_REVERSE\n\n\n0x0010\n\n\nSEQ being reverse complemented\n\n\n\n\n\n\nSAM.FLAG_MREVERSE\n\n\n0x0020\n\n\nSEQ of the next segment in the template being reverse complemented\n\n\n\n\n\n\nSAM.FLAG_READ1\n\n\n0x0040\n\n\nthe first segment in the template\n\n\n\n\n\n\nSAM.FLAG_READ2\n\n\n0x0080\n\n\nthe last segment in the template\n\n\n\n\n\n\nSAM.FLAG_SECONDARY\n\n\n0x0100\n\n\nsecondary alignment\n\n\n\n\n\n\nSAM.FLAG_QCFAIL\n\n\n0x0200\n\n\nnot passing filters, such as platform/vendor quality controls\n\n\n\n\n\n\nSAM.FLAG_DUP\n\n\n0x0400\n\n\nPCR or optical duplicate\n\n\n\n\n\n\nSAM.FLAG_SUPPLEMENTARY\n\n\n0x0800\n\n\nsupplementary alignment\n\n\n\n\n\n\n\n\n\n\nExamples\n\n\nTODO\n\n\n\n\nAccessors\n\n\n#\n\n\nBioAlignments.SAM.Reader\n \n \nType\n.\n\n\nSAM.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the SAM file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.header\n \n \nFunction\n.\n\n\nheader(reader::Reader)::Header\n\n\n\n\n\nGet the header of \nreader\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.Header\n \n \nType\n.\n\n\nSAM.Header()\n\n\n\n\n\nCreate an empty header.\n\n\nsource\n\n\n#\n\n\nBase.find\n \n \nMethod\n.\n\n\nfind(header::Header, key::AbstractString)::Vector{MetaInfo}\n\n\n\n\n\nFind metainfo objects satisfying \nSAM.tag(metainfo) == key\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.Writer\n \n \nType\n.\n\n\nWriter(output::IO, header::Header=Header())\n\n\n\n\n\nCreate a data writer of the SAM file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nheader=Header()\n: SAM header object\n\n\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.MetaInfo\n \n \nType\n.\n\n\nMetaInfo(str::AbstractString)\n\n\n\n\n\nCreate a SAM metainfo from \nstr\n.\n\n\nExamples\n\n\njulia\n SAM.MetaInfo(\n@CO    some comment\n)\nBioAlignments.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia\n SAM.MetaInfo(\n@SQ    SN:chr1 LN:12345\n)\nBioAlignments.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\n\n\n\n\nsource\n\n\nMetaInfo(tag::AbstractString, value)\n\n\n\n\n\nCreate a SAM metainfo with \ntag\n and \nvalue\n.\n\n\ntag\n is a two-byte ASCII string. If \ntag\n is \n\"CO\"\n, \nvalue\n must be a string; otherwise, \nvalue\n is an iterable object with key and value pairs.\n\n\nExamples\n\n\njulia\n SAM.MetaInfo(\nCO\n, \nsome comment\n)\nBioAlignments.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia\n string(ans)\n\n@CO    some comment\n\n\njulia\n SAM.MetaInfo(\nSQ\n, [\nSN\n =\n \nchr1\n, \nLN\n =\n 12345])\nBioAlignments.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\njulia\n string(ans)\n\n@SQ    SN:chr1 LN:12345\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.iscomment\n \n \nFunction\n.\n\n\niscomment(metainfo::MetaInfo)::Bool\n\n\n\n\n\nTest if \nmetainfo\n is a comment (i.e. its tag is \"CO\").\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.tag\n \n \nFunction\n.\n\n\ntag(metainfo::MetaInfo)::String\n\n\n\n\n\nGet the tag of \nmetainfo\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.value\n \n \nFunction\n.\n\n\nvalue(metainfo::MetaInfo)::String\n\n\n\n\n\nGet the value of \nmetainfo\n as a string.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.keyvalues\n \n \nFunction\n.\n\n\nkeyvalues(metainfo::MetaInfo)::Vector{Pair{String,String}}\n\n\n\n\n\nGet the values of \nmetainfo\n as string pairs.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.Record\n \n \nType\n.\n\n\nSAM.Record()\n\n\n\n\n\nCreate an unfilled SAM record.\n\n\nsource\n\n\nSAM.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a SAM record from \ndata\n. This function verifies the format and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nSAM.Record(str::AbstractString)\n\n\n\n\n\nCreate a SAM record from \nstr\n. This function verifies the format and indexes fields for accessors.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.flag\n \n \nFunction\n.\n\n\nflag(record::Record)::UInt16\n\n\n\n\n\nGet the bitwise flag of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.ismapped\n \n \nFunction\n.\n\n\nismapped(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.isprimary\n \n \nFunction\n.\n\n\nisprimary(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is a primary line of the read.\n\n\nThis is equivalent to \nflag(record) \n 0x900 == 0\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.refname\n \n \nFunction\n.\n\n\nrefname(record::Record)::String\n\n\n\n\n\nGet the reference sequence name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.position\n \n \nFunction\n.\n\n\nposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based leftmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.rightposition\n \n \nFunction\n.\n\n\nrightposition(record::Record)::Int\n\n\n\n\n\nGet the 1-based rightmost mapping position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.isnextmapped\n \n \nFunction\n.\n\n\nisnextmapped(record::Record)::Bool\n\n\n\n\n\nTest if the mate/next read of \nrecord\n is mapped.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.nextrefname\n \n \nFunction\n.\n\n\nnextrefname(record::Record)::String\n\n\n\n\n\nGet the reference name of the mate/next read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.nextposition\n \n \nFunction\n.\n\n\nnextposition(record::Record)::Int\n\n\n\n\n\nGet the position of the mate/next read of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.mappingquality\n \n \nFunction\n.\n\n\nmappingquality(record::Record)::UInt8\n\n\n\n\n\nGet the mapping quality of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.cigar\n \n \nFunction\n.\n\n\ncigar(record::Record)::String\n\n\n\n\n\nGet the CIGAR string of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.alignment\n \n \nFunction\n.\n\n\nalignment(record::Record)::BioAlignments.Alignment\n\n\n\n\n\nGet the alignment of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.alignlength\n \n \nFunction\n.\n\n\nalignlength(record::Record)::Int\n\n\n\n\n\nGet the alignment length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.tempname\n \n \nFunction\n.\n\n\ntempname(record::Record)::String\n\n\n\n\n\nGet the query template name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.templength\n \n \nFunction\n.\n\n\ntemplength(record::Record)::Int\n\n\n\n\n\nGet the template length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.sequence\n \n \nFunction\n.\n\n\nsequence(record::Record)::BioSequences.DNASequence\n\n\n\n\n\nGet the segment sequence of \nrecord\n.\n\n\nsource\n\n\nsequence(::Type{String}, record::Record)::String\n\n\n\n\n\nGet the segment sequence of \nrecord\n as \nString\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.seqlength\n \n \nFunction\n.\n\n\nseqlength(record::Record)::Int\n\n\n\n\n\nGet the sequence length of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.quality\n \n \nFunction\n.\n\n\nquality(record::Record)::Vector{UInt8}\n\n\n\n\n\nGet the Phred-scaled base quality of \nrecord\n.\n\n\nsource\n\n\nquality(::Type{String}, record::Record)::String\n\n\n\n\n\nGet the ASCII-encoded base quality of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioAlignments.SAM.auxdata\n \n \nFunction\n.\n\n\nauxdata(record::Record)::Dict{String,Any}\n\n\n\n\n\nGet the auxiliary data (optional fields) of \nrecord\n.\n\n\nsource", 
            "title": "BAM"
        }, 
        {
            "location": "/io/sam/#sam", 
            "text": "", 
            "title": "SAM"
        }, 
        {
            "location": "/io/sam/#description", 
            "text": "SAM is a text-based file format for representing sequence alignments.   Reader type:  SAM.Reader  Writer type:  SAM.Writer  Element type:  SAM.Record   This module provides 16-bit flags defined in the SAM specs:     Flag  Bit  Description      SAM.FLAG_PAIRED  0x0001  template having multiple segments in sequencing    SAM.FLAG_PROPER_PAIR  0x0002  each segment properly aligned according to the aligner    SAM.FLAG_UNMAP  0x0004  segment unmapped    SAM.FLAG_MUNMAP  0x0008  next segment in the template unmapped    SAM.FLAG_REVERSE  0x0010  SEQ being reverse complemented    SAM.FLAG_MREVERSE  0x0020  SEQ of the next segment in the template being reverse complemented    SAM.FLAG_READ1  0x0040  the first segment in the template    SAM.FLAG_READ2  0x0080  the last segment in the template    SAM.FLAG_SECONDARY  0x0100  secondary alignment    SAM.FLAG_QCFAIL  0x0200  not passing filters, such as platform/vendor quality controls    SAM.FLAG_DUP  0x0400  PCR or optical duplicate    SAM.FLAG_SUPPLEMENTARY  0x0800  supplementary alignment", 
            "title": "Description"
        }, 
        {
            "location": "/io/sam/#examples", 
            "text": "TODO", 
            "title": "Examples"
        }, 
        {
            "location": "/io/sam/#accessors", 
            "text": "#  BioAlignments.SAM.Reader     Type .  SAM.Reader(input::IO)  Create a data reader of the SAM file format.  Arguments   input : data source   source  #  BioAlignments.SAM.header     Function .  header(reader::Reader)::Header  Get the header of  reader .  source  #  BioAlignments.SAM.Header     Type .  SAM.Header()  Create an empty header.  source  #  Base.find     Method .  find(header::Header, key::AbstractString)::Vector{MetaInfo}  Find metainfo objects satisfying  SAM.tag(metainfo) == key .  source  #  BioAlignments.SAM.Writer     Type .  Writer(output::IO, header::Header=Header())  Create a data writer of the SAM file format.  Arguments   output : data sink  header=Header() : SAM header object   source  #  BioAlignments.SAM.MetaInfo     Type .  MetaInfo(str::AbstractString)  Create a SAM metainfo from  str .  Examples  julia  SAM.MetaInfo( @CO    some comment )\nBioAlignments.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia  SAM.MetaInfo( @SQ    SN:chr1 LN:12345 )\nBioAlignments.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345  source  MetaInfo(tag::AbstractString, value)  Create a SAM metainfo with  tag  and  value .  tag  is a two-byte ASCII string. If  tag  is  \"CO\" ,  value  must be a string; otherwise,  value  is an iterable object with key and value pairs.  Examples  julia  SAM.MetaInfo( CO ,  some comment )\nBioAlignments.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia  string(ans) @CO    some comment \n\njulia  SAM.MetaInfo( SQ , [ SN  =   chr1 ,  LN  =  12345])\nBioAlignments.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\njulia  string(ans) @SQ    SN:chr1 LN:12345   source  #  BioAlignments.SAM.iscomment     Function .  iscomment(metainfo::MetaInfo)::Bool  Test if  metainfo  is a comment (i.e. its tag is \"CO\").  source  #  BioAlignments.SAM.tag     Function .  tag(metainfo::MetaInfo)::String  Get the tag of  metainfo .  source  #  BioAlignments.SAM.value     Function .  value(metainfo::MetaInfo)::String  Get the value of  metainfo  as a string.  source  #  BioAlignments.SAM.keyvalues     Function .  keyvalues(metainfo::MetaInfo)::Vector{Pair{String,String}}  Get the values of  metainfo  as string pairs.  source  #  BioAlignments.SAM.Record     Type .  SAM.Record()  Create an unfilled SAM record.  source  SAM.Record(data::Vector{UInt8})  Create a SAM record from  data . This function verifies the format and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  SAM.Record(str::AbstractString)  Create a SAM record from  str . This function verifies the format and indexes fields for accessors.  source  #  BioAlignments.SAM.flag     Function .  flag(record::Record)::UInt16  Get the bitwise flag of  record .  source  #  BioAlignments.SAM.ismapped     Function .  ismapped(record::Record)::Bool  Test if  record  is mapped.  source  #  BioAlignments.SAM.isprimary     Function .  isprimary(record::Record)::Bool  Test if  record  is a primary line of the read.  This is equivalent to  flag(record)   0x900 == 0 .  source  #  BioAlignments.SAM.refname     Function .  refname(record::Record)::String  Get the reference sequence name of  record .  source  #  BioAlignments.SAM.position     Function .  position(record::Record)::Int  Get the 1-based leftmost mapping position of  record .  source  #  BioAlignments.SAM.rightposition     Function .  rightposition(record::Record)::Int  Get the 1-based rightmost mapping position of  record .  source  #  BioAlignments.SAM.isnextmapped     Function .  isnextmapped(record::Record)::Bool  Test if the mate/next read of  record  is mapped.  source  #  BioAlignments.SAM.nextrefname     Function .  nextrefname(record::Record)::String  Get the reference name of the mate/next read of  record .  source  #  BioAlignments.SAM.nextposition     Function .  nextposition(record::Record)::Int  Get the position of the mate/next read of  record .  source  #  BioAlignments.SAM.mappingquality     Function .  mappingquality(record::Record)::UInt8  Get the mapping quality of  record .  source  #  BioAlignments.SAM.cigar     Function .  cigar(record::Record)::String  Get the CIGAR string of  record .  source  #  BioAlignments.SAM.alignment     Function .  alignment(record::Record)::BioAlignments.Alignment  Get the alignment of  record .  source  #  BioAlignments.SAM.alignlength     Function .  alignlength(record::Record)::Int  Get the alignment length of  record .  source  #  BioAlignments.SAM.tempname     Function .  tempname(record::Record)::String  Get the query template name of  record .  source  #  BioAlignments.SAM.templength     Function .  templength(record::Record)::Int  Get the template length of  record .  source  #  BioAlignments.SAM.sequence     Function .  sequence(record::Record)::BioSequences.DNASequence  Get the segment sequence of  record .  source  sequence(::Type{String}, record::Record)::String  Get the segment sequence of  record  as  String .  source  #  BioAlignments.SAM.seqlength     Function .  seqlength(record::Record)::Int  Get the sequence length of  record .  source  #  BioAlignments.SAM.quality     Function .  quality(record::Record)::Vector{UInt8}  Get the Phred-scaled base quality of  record .  source  quality(::Type{String}, record::Record)::String  Get the ASCII-encoded base quality of  record .  source  #  BioAlignments.SAM.auxdata     Function .  auxdata(record::Record)::Dict{String,Any}  Get the auxiliary data (optional fields) of  record .  source", 
            "title": "Accessors"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nWe appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.\n\n\nIf you have a question about contributing or using this package, you are encouraged to use the \nBio category of the Julia discourse site\n.\n\n\nDetailed guidance for contributing to all BioJulia packages is provided at the \nBioJulia Contribution Documentation\n.\n\n\nHere we list specific details about contributing and maintainership pertaining specifically to the BioSequences.jl package.\n\n\n\n\nNamed maintainers\n\n\nThe named maintainers of this package are Kenta Sato and Ben Ward. It is their responsibility to make final choices about pull requests and issues, although because of our community structure, you will find other maintainers assisting them.\n\n\n\n\nBranching model\n\n\nThe branching model used to develop and make releases of this package is the \nOneFlow\n model summarized in the \nBioJulia Contribution Documentation", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.  If you have a question about contributing or using this package, you are encouraged to use the  Bio category of the Julia discourse site .  Detailed guidance for contributing to all BioJulia packages is provided at the  BioJulia Contribution Documentation .  Here we list specific details about contributing and maintainership pertaining specifically to the BioSequences.jl package.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#named-maintainers", 
            "text": "The named maintainers of this package are Kenta Sato and Ben Ward. It is their responsibility to make final choices about pull requests and issues, although because of our community structure, you will find other maintainers assisting them.", 
            "title": "Named maintainers"
        }, 
        {
            "location": "/contributing/#branching-model", 
            "text": "The branching model used to develop and make releases of this package is the  OneFlow  model summarized in the  BioJulia Contribution Documentation", 
            "title": "Branching model"
        }
    ]
}